<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://blog.jkkitakita.dev/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>DMM.go #1</title></head><body><header id=banner><h2><a href=https://blog.jkkitakita.dev>jkkitakita</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>DMM.go #1</h1><div><time>January 23, 2020</time></div></header><p>DMM さんの Go の勉強会に行ってきたので、その時のメモ。</p><p><a href=https://dmm.connpass.com/event/157222/>https://dmm.connpass.com/event/157222/</a></p><p>適宜、スライド追記されたら更新する予定。</p><h2 id=タイムスケジュール>タイムスケジュール</h2><p><img src=/images/dmm_go_01.png alt=dmm_go_01></p><p>c.f. <a href=https://dmm.connpass.com/event/157222/>DMM.go #1</a>
（スクショがダメだったら、削除します。）</p><h2 id=内容>内容</h2><h3 id=オープニング開催趣旨-i35_267httpstwittercomi35_267>オープニング・開催趣旨 <a href=https://twitter.com/i35_267>@i35_267</a></h3><ul><li>会場案内</li><li>DMM グループの Go の勉強会です<ul><li><a href=https://www.dmm.com/>DMM.com</a></li><li><a href=https://games.dmm.com/>DMM GAMES</a></li><li><a href=https://picappinc.jp/>PicApp</a></li></ul></li></ul><h3 id=cloud-native-な時代に考える-monorepo-y_matsuwitterhttpstwittercomy_matsuwitter>Cloud Native な時代に考える monorepo <a href=https://twitter.com/y_matsuwitter>@y_matsuwitter</a></h3><h4 id=cloud-native-時代の開発と現状>Cloud Native 時代の開発と現状</h4><ul><li>マイクロサービスが前提になってきている</li><li>組織戦略とも絡んでくるよね。ってなって monorepo をテーマにしようと思った。</li></ul><h4 id=改めてcloud-native-とは>改めて、Cloud Native とは</h4><ul><li><a href=https://github.com/cncf/toc/blob/master/DEFINITION.md#%E6%97%A5%E6%9C%AC%E8%AA%9E%E7%89%88>CNCF が出している Cloud Native の定義</a>の紹介</li><li>Cloud の利点を適切に理解して、使う必要があるよね。</li></ul><h4 id=cloud-native-時代の基盤の選択肢>Cloud Native 時代の基盤の選択肢</h4><ul><li>Kubernetes</li><li>Container as a Service</li><li>FaaS</li><li>Managed Service</li><li>とかとか、いろいろなユースケースがあって</li><li>アーキテクチャは、チームと寄り添いながら、運営していく必要がある。</li></ul><h4 id=そこでなんで-monorepo-なのか>そこで、なんで monorepo なのか？</h4><ul><li>アプリケーションが色々散らばっている。</li><li>かつ、そのプロトコルも複数ある。</li><li>特に Managed Service は、プロトコルが決まっていて、それぞれ使わないといけないプロトコルが決まっていたりする。</li><li>monorepo という選択肢がいいんじゃないか。</li></ul><h4 id=monorepo-とは>monorepo とは？</h4><ul><li>Package 間の interface を一括管理できる</li></ul><h4 id=なぜ-monorepo>なぜ monorepo？</h4><ul><li>パッケージ間の interface を 1 つのリポジトリに集約する</li><li>仕組みの共有が容易。</li></ul><h4 id=go-と-bazel-で-cloud-native-な-monorepo-運用>Go と bazel で Cloud Native な monorepo 運用</h4><h5 id=課題>課題</h5><ul><li>全サービスのソースコードが集まる<ul><li>全体をビルドしテストするコストは、サービスが拡大するごとに増える</li></ul></li><li>ビルド方法の多様化<ul><li>様々な基盤に合わせたツールが必要になる</li></ul></li></ul><h5 id=対策>対策</h5><ul><li>賢いビルドツール<ul><li>依存関係の解析</li><li>依存グラフから再ビルド・再テスト</li></ul></li></ul><h4 id=そこでbazelhttpsbazelbuildの登場>そこで、<a href=https://bazel.build/>bazel</a>の登場</h4><h5 id=特徴>特徴</h5><ul><li>依存関係に応じて、影響する部分を特定ビルド</li><li>ビルド結果のキャッシュにより、不要なビルドを行わない</li><li>キャッシュはローカルだけではなく、リモート環境も指定可能。</li><li>様々な言語に対応している。</li></ul><h4 id=go-と-bazel-で-monorepo>Go と bazel で monorepo</h4><h5 id=gazellehttpsgithubcombazelbuildbazel-gazelle><a href=https://github.com/bazelbuild/bazel-gazelle>Gazelle</a></h5><ul><li>ビルド対象・依存関係を細かく指定する必要がない。<ul><li>依存関係を自動生成してくれる。</li></ul></li><li>bazel を運用するには、ほぼ必須（？）</li></ul><h5 id=bazel-の課題>bazel の課題</h5><ul><li>依存関係を全て記述する必要がある<ul><li>各言語</li></ul></li><li>bazel 自体の機能が豊富すぎる<ul><li>学習コストが高め</li><li>bazel の面倒をみる。DevOps 的なチームが必要。</li></ul></li></ul><h5 id=各ツールとの組み合わせ>各ツールとの組み合わせ</h5><ul><li>protobuf との相性<ul><li>bazel 側機能を利用すると都度 go コードを生成してしまう。<ul><li>生成結果もコミットしたい場合は、bazel を使わない必要がある？</li></ul></li></ul></li><li>ほとんどの生成過程を bazel のキャッシュディレクトリで実施する必要がある。</li></ul><h3 id=practical-distributed-tracing-hatsunemiku3939httpsgithubcomhatsunemiku3939>PRACTICAL DISTRIBUTED TRACING <a href=https://github.com/HatsuneMiku3939>@HatsuneMiku3939</a></h3><div style=position:relative;padding-bottom:56.25%;padding-top:30px;height:0;overflow:hidden><iframe src=//docs.google.com/presentation/d/1HVSQaEU1rsycka--QYKaODJHO1eNPNlmk0tz_ON_YYM style=position:absolute;top:0;left:0;width:100%;height:100% allowfullscreen frameborder=0></iframe></div><p><a href="https://docs.google.com/presentation/d/1HVSQaEU1rsycka--QYKaODJHO1eNPNlmk0tz_ON_YYM/edit#slide=id.g33148270ac_0_143">PRACTICAL DISTRIBUTED TRACING</a></p><h4 id=マイクロサービスで出てくる分散トレーシングの話>マイクロサービスで出てくる。分散トレーシングの話。</h4><ul><li>分散アプリの性能を計測する仕組み。</li><li>従来の APM と何が違う？<ul><li>1 リクエスト（従来の APM） -> 複数バックエンド（分散トレーシング）</li><li>個々のサービスを測定（従来の APM） -> 全体は把握できない。（分散トレーシング）</li></ul></li><li>リクエスト全体の「処理の流れ」を把握するモノ。<ul><li>処理の単位は、Trace と Span に分かれている</li></ul></li></ul><h4 id=trace>Trace</h4><ul><li>システムを貫通するリクエストの集合体</li></ul><h4 id=span>Span</h4><ul><li>作業の単位</li><li>1 Trace は 1 以上の Span で構成される</li><li>前後がわかるように親子関係を持っている</li></ul><h4 id=基本はあるサービスの-outbound-は他のサービスの-inbound>基本は、「あるサービスの Outbound は、他のサービスの Inbound。」</h4><h5 id=inbound-するとき>Inbound するとき</h5><ul><li>とりあえず、新しい Span を生成</li><li>親子関係を作成する</li><li>TraceID がなかったら、作る</li></ul><h5 id=outbound-するとき>Outbound するとき</h5><ul><li>Span ID 伝搬する。<ul><li>基本は Header。（ダメなら、body？）<ul><li>gRPC, kafka etc&mldr;</li></ul></li></ul></li></ul><h4 id=opencensus>OpenCensus</h4><h5 id=opencensus-とは>OpenCensus とは。</h5><ul><li>問題は、ソリューションがいっぱいあって、SDK がそれぞれ異なるが、これを選んだ。</li><li>一番しっかりできていると思っている。</li><li>いろいろな機能があるが、主な目的は、分散トレーシング。</li><li>StackDriver とか X-ray とかにも export することができる。<ul><li>c.f. <a href=https://opencensus.io/exporters/>https://opencensus.io/exporters/</a></li></ul></li></ul><h5 id=やるべき-3-つのこと>やるべき 3 つのこと</h5><ul><li>Exporter の初期化<ul><li>Jaeger の例を出してますが、ほぼコピペで行ける。</li></ul></li><li>Inbound トレーシング</li><li>Outbound トレーシング</li></ul><p>基本的にこれだけ。</p><h5 id=他にも機能がいっぱい>他にも機能がいっぱい！</h5><ul><li>gRPC tracing</li><li>Server Clent metric</li><li>DB Integration etc&mldr;</li></ul><h5 id=実戦運用>実戦運用</h5><ul><li>小規模なら Agent なし<ul><li>直接 backend に送れば ok! e.g. X-ray, Datadog<ul><li>コピペで行ける</li></ul></li></ul></li><li>大規模なら Agent あり<ul><li>各 instance に OpenCensus Agent を用意して、各種サービスから Agent に送る<ul><li>Kubernetes なら、daemonset で用意する。</li></ul></li><li>一度 Agent が受けて、その後、backend に送れば ok.</li></ul></li></ul><h4 id=最後に>最後に</h4><ul><li>ただ、OpenCensus は OpenTracing と統合されて、OpenTelementary になる。</li></ul><h3 id=vcr-in-goモック自動生成で楽しちゃう話-yyh_glhttpstwittercomyyh_gl>VCR in Go：モック自動生成で楽しちゃう話 <a href=https://twitter.com/yyh_gl>@yyh_gl</a></h3><div class=embed><script async class=speakerdeck-embed data-id=e03f7c5484e84f7eac649202ea4c2327 data-slide data-ratio=1.77777777777777 src=//speakerdeck.com/assets/embed.js></script></div><h4 id=はじめに>はじめに</h4><ul><li>皆さんテスト書いてますか？</li><li>外部システムをモック化したい</li><li>モック管理あるある<ul><li>ただ、「モックだから動けばいっか？」みたいなことが多いはず。</li></ul></li><li>モックを手動で作成する時点でもうきつい。</li><li>なので、モックコードを自動生成する<ul><li>OpenAPI（Swagger）</li><li>Video Cassette Recorder</li></ul></li></ul><h4 id=vcr>VCR</h4><ul><li>大事なのは、確実に、実際のレスポンスをモック化できること</li><li>紹介するのは、<a href=https://github.com/dnaeon/go-vcr>dnaeon/go-vcr</a><ul><li><a href=https://github.com/vcr/vcr>vcr/vcr</a>の Go バージョン</li></ul></li></ul><h5 id=基本的な要素は２つ>基本的な要素は２つ</h5><h6 id=recorder>Recorder</h6><ul><li>レスポンスを記録するやつ</li><li>実態は、構造体</li></ul><h6 id=casete>Casete</h6><ul><li>保存したレスポンス</li><li>yaml</li></ul><h5 id=特徴と運用方法>特徴と運用方法</h5><ul><li>リクエストの同一性について<ul><li>デフォルトでは、下記パラメータが同じであれば、同一リクエストとして判定</li></ul></li><li>保存内容を修正したいときは、cassette を消せば ok!<ul><li>yaml を直接修正は、おすすめしない。</li></ul></li><li>運用方法<ul><li>STG 環境のレスポンスを保存</li><li>テスト関数ごとにカセットを用意</li></ul></li></ul><h5 id=メリットデメリット>メリット・デメリット</h5><ul><li>メリット<ul><li>モックと実システム間の仕様のズレがなくなり。</li><li>HTTP ではなく、ファイルの読み込みでよくなって、早くなる。</li><li>「ローカルでは動いたのに、、、」が減る！</li></ul></li><li>デメリット<ul><li>アクセストークンの再取得</li><li>カセット単位でレスポンス</li></ul></li></ul><h3 id=チャット小説アプリ-teller-を支える-gaego-tomoemonhttpstwittercomtomoemon>チャット小説アプリ TELLER を支える GAE/Go <a href=https://twitter.com/tomoemon>@tomoemon</a></h3><h4 id=はじめに-1>はじめに</h4><ul><li>Go よりかは、プロダクト寄りの話多め。</li><li>チャット型小説アプリ TELLER の紹介</li><li>パッケージ依存関係 CI<ul><li>クリーンアーキテクチャに変えてみたが、どこからどこへ依存して良いのか、何をどこに書くべきかわからないメンバーもいた。</li><li>Golang のパッケージ依存関係チェックツールを作って、CI<ul><li><a href=https://github.com/tomoemon/impas>https://github.com/tomoemon/impas</a></li></ul></li></ul></li></ul><h4 id=di-自動化したい>DI 自動化したい</h4><ul><li>DI 自動化したい。<a href=https://github.com/google/wire>wire</a>入れよう！</li><li>後々ジョインするメンバーの参入障壁があがる？</li><li>詳細的に言語機能との差異が生まれて負債にならないか？</li></ul><h4 id=課題と対策>課題と対策</h4><ul><li>広告で見たストーリーを見つけられない<ul><li>2 年前は検索機能がなかった。</li><li>色々検索サービスを検討した<ul><li>Elasticsearch</li><li>GAE Search</li><li>Algolia</li></ul></li><li>機能の学習コスト等の観点から、結局、Algolia にした</li></ul></li><li>Algolia<ul><li>ソートの癖がすごい。</li><li>料金プランが 1 年スパンでどんどん変わる<ul><li>使い始めて、1 年後には、無料だったものに、従量課金されてた。</li></ul></li><li>インデックスしたはずが Algolia 上にない<ul><li>問い合わせたら、再インデックスしてくれと言われる</li></ul></li></ul></li><li>Redis でランキング集計つらい<ul><li>Redis -> BigQuery に変えた。</li></ul></li><li>ストーリー更新をトリガーにして色々したい<ul><li>イベント駆動にした。Cloud Tasks を使って解決できた。</li></ul></li><li>アダルト画像を上げまくるユーザーをどうにかしたい。<ul><li><a href=http://e-words.jp/w/CGM.html>CGM</a>あるある。</li><li>元々は、外注して、人力目視チェック。</li><li><a href="https://cloud.google.com/vision/?hl=ja&utm_source=google&utm_medium=cpc&utm_campaign=japac-JP-all-ja-dr-bkws-all-all-trial-e-dr-1008074&utm_content=text-ad-none-none-DEV_c-CRE_285865410190-ADGP_Hybrid+%7C+AW+SEM+%7C+BKWS+~+T1+%7C+EXA+%7C+ML+%7C+M:1+%7C+JP+%7C+ja+%7C+Vision+%7C+General+%7C+en-KWID_43700016101235133-kwd-203288729047&userloc_1009310&utm_term=KW_cloud%20vision%20api&gclid=Cj0KCQiApaXxBRDNARIsAGFdaB_G25M6NkjchBaI210iZ8crRUvX8i70dRlKe_vhCRMbatl0CX6P4NYaAhA4EALw_wcB">Cloud Vision API</a>を使えばよくね？<ul><li>サツマイモの画像でも、Violence な画像と判定されてしまうなどの精度の問題があった。</li><li>最終的には、一次切り分けとして Cloud Vision API を利用することとした。</li></ul></li></ul></li><li>ユーザ権限管理<ul><li>Role interface を実装 e.g. func CanXXXX() bool</li></ul></li></ul><h2 id=参考>参考</h2><ul><li><a href=https://www.cncf.io/>CNCF</a></li><li>Bazel 関連<ul><li><a href=https://github.com/bazelbuild/rules_go>Go rules for Bazel</a><ul><li>基本はここを見て、やるのが良さそう？</li></ul></li><li><a href=https://medium.com/mixi-developers/go-project-with-bazel-ad807ba19f5c>Go と Bazel</a></li><li><a href=https://qiita.com/mmmknt/items/cb23a597dfb5a4ca6353>Golang+Bazel で依存ライブラリをいい感じに管理する</a></li><li><a href=https://qiita.com/akrisn/items/ebb77073824c3d6fcde1>ProtocolBuffers を使っている Go のプロジェクトを Bazel でビルドする</a></li></ul></li><li><a href=https://opentelemetry.io/>OpenTelemetry</a></li></ul></article></main><footer id=footer></footer></body></html>